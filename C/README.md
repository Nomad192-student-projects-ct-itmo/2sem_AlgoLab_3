# C. Самое дешевое ребро
```diff
+ Полное решение +
# GNU C++14 | 1153 мс | 113232 КБ #
```
| Правила                                     	|
|:---------------------------------------------:|
| ограничение по времени на тест: 4 секунды     |
| ограничение по памяти на тест: 256 мегабайт   |
| ввод: стандартный ввод                        |
| вывод: стандартный вывод                      |

Дано подвешенное дерево с корнем в первой вершине. Все ребра имеют веса (стоимости). Вам нужно ответить на ***M*** запросов вида "найти у двух вершин минимум среди стоимостей ребер пути между ними".

## Входные данные
В первой строке задано целое число ***n*** — число вершин в дереве (***1 ≤ n ≤ 2·10<sup>5</sup>***).

В следующих ***n - 1*** строках записаны два целых числа ***x*** и ***y***. Число ***x*** на строке ***i*** означает, что ***x*** — предок вершины ***i***, y задает стоимость ребра (***x < i; |y| ≤ 10<sup>6</sup>***).

Далее заданы m (***0 ≤ m ≤ 5·10<sup>5</sup>***) запросов вида (***x, y***) — найти минимум на пути из ***x*** в ***y*** (***1 ≤ x, y ≤ n; x ≠ y***).

## Выходные данные
Выведите ответы на запросы.

## Примеры
входные данные
```
5
1 2
1 3
2 5
3 2
2
2 3
4 5
```
выходные данные
```
2
2
```
---
входные данные
```
5
1 1
1 2
2 3
3 4
2
1 4
3 2
```
выходные данные
```
1
1
```
